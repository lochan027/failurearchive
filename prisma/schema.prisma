// Failure Archive - Research-grade platform for structured failure knowledge
// Core Philosophy: NOT a social network. Academic, neutral, precise.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTICATION & IDENTITY
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  emailVerified DateTime?
  password      String?   // Hashed password for email/password auth
  name          String?
  image         String?
  
  // OAuth accounts
  accounts      Account[]
  sessions      Session[]
  
  // Failure submissions
  submissions   FailureRecord[]
  
  // Reuse tracking
  reuses        ReuseRecord[]
  
  // Notifications
  notifications ReuseNotification[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model AnonymousToken {
  id        String   @id @default(cuid())
  token     String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  
  submissions FailureRecord[]
}

// ============================================
// FAILURE RECORDS - Core Data Model
// ============================================

enum FailureRecordType {
  TECHNICAL_PROJECT
  RESEARCH_PAPER
  RESEARCH_IDEA
  BUSINESS_IDEA
  FUTURE_TECH_IDEA
  AI_PROJECT
}

enum IdentityMode {
  ANONYMOUS
  PSEUDONYMOUS
  DELAYED_30
  DELAYED_90
  DELAYED_180
  ATTRIBUTED
}

enum SubmissionStatus {
  DRAFT
  PENDING_MODERATION
  PUBLISHED
  ARCHIVED
  WITHDRAWN
  FLAGGED
}

enum FailurePoint {
  ASSUMPTION_INVALIDATED
  DATA_BIAS
  TECHNICAL_CEILING
  USER_BEHAVIOR_MISMATCH
  MARKET_ILLUSION
  TIMING_MISMATCH
  SCALING_FAILURE
  DISTRIBUTION_FAILURE
  COST_STRUCTURE
}

enum EvidenceLevel {
  NONE
  ANECDOTAL
  METRICS
  RESEARCH_GRADE
  REPRODUCIBLE
}

model FailureRecord {
  id                String              @id @default(cuid())
  
  // Type & Status
  type              FailureRecordType
  status            SubmissionStatus    @default(DRAFT)
  
  // Identity (one or the other)
  userId            String?
  anonymousTokenId  String?
  identityMode      IdentityMode        @default(ATTRIBUTED)
  pseudonymousId    String?             // e.g., "FA-2041"
  attributionDate   DateTime?           // For delayed attribution
  
  // Licensing (MANDATORY)
  licenseAccepted   Boolean             @default(false)
  textLicense       String              @default("CC0-1.0")
  codeLicense       String              @default("MIT")
  
  // Core Structured Fields
  title             String
  hypothesis        String              @db.Text // "We believed ___ would work because ___"
  method            String              @db.Text // What was built or tested
  failurePoints     FailurePoint[]      // Multi-select
  keyMisunderstanding String            @db.Text // "We assumed ___, but reality was ___"
  salvageableKnowledge String           @db.Text
  
  // Evidence
  evidenceLevel     EvidenceLevel       @default(ANECDOTAL)
  githubLink        String?
  pdfUrl            String?             // For research papers
  metrics           String?             @db.Text
  logs              String?             @db.Text
  charts            Json?               // Array of chart data/URLs
  
  // Type-specific fields (JSON for flexibility)
  typeSpecificData  Json?               // Different structure per type
  
  // Taxonomy & Discovery
  domain            String[]            // e.g., ["ML", "Healthcare"]
  tags              String[]
  aiExtractedTags   String[]            // Auto-generated by AI
  stage             String?             // idea, prototype, scale
  
  // Reuse tracking
  reuseCount        Int                 @default(0)
  avoidedCount      Int                 @default(0)
  referenceCount    Int                 @default(0)
  
  // Relations
  user              User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  anonymousToken    AnonymousToken?     @relation(fields: [anonymousTokenId], references: [id])
  reuses            ReuseRecord[]
  moderationRecords ModerationRecord[]
  
  // Timestamps
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  publishedAt       DateTime?
  
  @@index([type])
  @@index([status])
  @@index([domain])
  @@index([evidenceLevel])
  @@index([createdAt])
  @@index([reuseCount])
}

// ============================================
// REUSE SYSTEM (NOT COMMENTS)
// ============================================

enum ReuseType {
  REUSED           // Built upon
  AVOIDED          // Prevented same mistake
  REFERENCED       // Cited in research
}

model ReuseRecord {
  id              String      @id @default(cuid())
  
  failureRecordId String
  userId          String
  
  type            ReuseType
  privateNotes    String?     @db.Text // Private to the user
  
  // Relations
  failureRecord   FailureRecord @relation(fields: [failureRecordId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
  
  @@unique([failureRecordId, userId, type])
}

model ReuseNotification {
  id              String   @id @default(cuid())
  
  userId          String
  failureRecordId String
  reuseType       ReuseType
  
  read            Boolean  @default(false)
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@index([userId, read])
}

// ============================================
// AI MODERATION & ANALYSIS
// ============================================

enum ModerationStatus {
  PENDING
  APPROVED
  FLAGGED
  REJECTED
}

enum ModerationFlag {
  ILLEGAL_CONTENT
  MALWARE_LINK
  SCAM_PATTERN
  HATE_HARASSMENT
  PLAGIARISM_RISK
  FAKE_CITATION
  SPAM
}

model ModerationRecord {
  id              String            @id @default(cuid())
  
  failureRecordId String
  
  status          ModerationStatus  @default(PENDING)
  flags           ModerationFlag[]
  aiAnalysis      Json?             // AI scan results
  manualReview    Boolean           @default(false)
  reviewNotes     String?           @db.Text
  
  failureRecord   FailureRecord     @relation(fields: [failureRecordId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@index([status])
}

model AIKnowledgeExtraction {
  id              String   @id @default(cuid())
  
  failureRecordId String   @unique
  
  normalizedHypothesis String? @db.Text
  taxonomyTags         String[]
  similarFailureIds    String[] // IDs of similar failures
  commonPatterns       String[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
